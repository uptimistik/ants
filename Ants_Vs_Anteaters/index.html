<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Telegram Mini App</title>
    <link rel="stylesheet" type="text/css" href="css/gse-style.css" />
    <link rel="stylesheet" type="text/css" href="css/gse-style-loading.css" />
    <style type="text/css">
        body {
            background-color: black;
            margin: 0;
            padding: 0;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div id="gse-player" class="gse-frame">
        <div class="gse-overlay">
            <div id="gse-text" class="gse-dialog">
                <div>
                    <button id="gse-text-cancel">Cancel</button>
                    <button id="gse-text-done">Done</button>
                    <p id="gse-text-prompt"></p>
                </div>
                <div>
                    <textarea id="gse-text-input"></textarea>
                </div>
            </div>
            <div id="gse-loading" style="visibility: visible;">
                <img src="images/gse-loading.png" />
            </div>
        </div>
    </div>
    <script type="text/javascript">
        (function (global) {
            const CLIENT_ID = 'AL1szGybA0YVtyC5Jk5w3z6hBPCPvy6P';
            const FRACTAL_API_BASE_URL = 'https://auth-api.fractal.is';
            let codeVerifier, codeChallenge, authCode;

            function generateCodeVerifier() {
                const array = new Uint32Array(56 / 2);
                window.crypto.getRandomValues(array);
                return Array.from(array, dec => ('0' + dec.toString(16)).substr(-2)).join('');
            }

            async function generateCodeChallenge(verifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(verifier);
                const digest = await window.crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
                    .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
            }

            async function getApprovalUrl() {
                console.log('Generating approval URL...');
                codeVerifier = generateCodeVerifier();
                codeChallenge = await generateCodeChallenge(codeVerifier);

                const authUrl = `${FRACTAL_API_BASE_URL}/auth/signin_v2/authorize`;
                const response = await fetch(authUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        clientId: CLIENT_ID,
                        scopes: ['identify', 'coins:read', 'items:read'],
                        codeChallenge: codeChallenge
                    })
                });

                const data = await response.json();
                console.log('Approval URL data:', data);
                return data.approvalUrl;
            }

            function extractAuthCodeFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('code');
            }

            async function verifyAuthentication() {
                console.log('Verifying authentication...');
                authCode = extractAuthCodeFromUrl();
                if (!authCode) {
                    console.error('Auth code not found in URL');
                    return;
                }

                const tokenUrl = `${FRACTAL_API_BASE_URL}/auth/signin_v2/token`;
                const response = await fetch(tokenUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        clientId: CLIENT_ID,
                        code: authCode,
                        codeVerifier: codeVerifier
                    })
                });

                const data = await response.json();
                console.log('Authentication verification data:', data);
                return data;
            }

            async function authenticateUser() {
                try {
                    const approvalUrl = await getApprovalUrl();
                    console.log('Approval URL:', approvalUrl);
                    window.location.href = approvalUrl;
                } catch (error) {
                    console.error('Error in authenticateUser:', error);
                }
            }

            async function postScore(accessToken, userId, score) {
                console.log(`Posting score: ${score} for user: ${userId}`);
                const postScoreUrl = `${FRACTAL_API_BASE_URL}/scores`;
                const response = await fetch(postScoreUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`
                    },
                    body: JSON.stringify({
                        userId: userId,
                        score: {
                            type: 'TotalKills',
                            value: score
                        }
                    })
                });

                const data = await response.json();
                console.log('Post score data:', data);
                return data;
            }

            async function fetchLeaderboard(accessToken) {
                console.log('Fetching leaderboard...');
                const leaderboardUrl = `${FRACTAL_API_BASE_URL}/leaderboard`;
                const response = await fetch(leaderboardUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                const data = await response.json();
                console.log('Leaderboard data:', data);
                return data;
            }

            function sendLoLMessage(messageName, payloadObj) {
                console.log(`Sending LoL message: ${messageName}`);
                parent.postMessage({
                    message: messageName,
                    payload: JSON.stringify(payloadObj)
                }, '*');
            }

            global.onEngineLoad = function () {
                gse.ready(function (engine) {
                    console.log('GameSalad engine ready');
                    var loadingElement = document.getElementById('gse-loading');

                    var playerDelegate = {
                        onLoadingBegin: function () {
                            console.log('Loading Begin');
                            engine.showOverlay();
                            loadingElement.style.visibility = 'visible';
                        },
                        onLoadingEnd: function () {
                            console.log('Loading End');
                            loadingElement.style.visibility = 'hidden';
                            engine.hideOverlay();
                        },
                        onWindowResize: function () {
                            console.log('Window Resize');
                            engine.relayout();
                        },
                        onGameCenterLogin: function () {
                            return new Promise(async (resolve, reject) => {
                                console.log('GameCenterLogin triggered');
                                try {
                                    await authenticateUser();
                                    resolve();
                                } catch (error) {
                                    console.error('Error in onGameCenterLogin:', error);
                                    reject(error);  // Reject the promise to indicate login failure
                                }
                            });
                        },
                        onGameCenterPostScore: function (score, leaderboard) {
                            return new Promise(async (resolve, reject) => {
                                console.log('GameCenterPostScore triggered:', score, leaderboard);
                                try {
                                    const authData = await verifyAuthentication();
                                    const scorePostResponse = await postScore(authData.accessToken, authData.userId, score);
                                    console.log('Score Post Response:', scorePostResponse);
                                    resolve();
                                } catch (error) {
                                    console.error('Error in onGameCenterPostScore:', error);
                                    reject(error);
                                }
                            });
                        },
                        onGameCenterShowLeaderboard: function () {
                            return new Promise(async (resolve, reject) => {
                                console.log('GameCenterShowLeaderboard triggered');
                                try {
                                    const authData = await verifyAuthentication();
                                    const leaderboardData = await fetchLeaderboard(authData.accessToken);
                                    console.log('Leaderboard Data:', leaderboardData);

                                    // Send leaderboard data to GameSalad
                                    leaderboardData.forEach((entry, index) => {
                                        engine.postEvent('externalWriteGameTableCell', null, `Leaderboard.Username`, index + 1, entry.userId);
                                        engine.postEvent('externalWriteGameTableCell', null, `Leaderboard.TotalKills`, index + 1, entry.value);
                                    });

                                    resolve();
                                } catch (error) {
                                    console.error('Error in onGameCenterShowLeaderboard:', error);
                                    reject(error);
                                }
                            });
                        },
                        onGameDimensionsKnown: function (width, height) {
                            console.log('Game dimensions known:', width, height);
                        },
                        onGameReady: function (width, height) {
                            console.log('Game is Ready:', width, height);
                        }
                    };

                    engine.appendDelegate(playerDelegate);
                    window.addEventListener('resize', playerDelegate.onWindowResize, false);

                    engine.setRenderFrame('gse-player');
                    engine.setOptions({
                        'viewport-reference': 'window',
                        'viewport-fit': 'letterbox'
                    });
                    engine.loadOptionsFromURL();
                    engine.play();
                });
            };

            // Check if returning from authentication
            if (window.location.search.includes('code')) {
                verifyAuthentication().then(authData => {
                    console.log('Authentication successful:', authData);
                    // Handle post-authentication actions, e.g., fetching leaderboard
                }).catch(error => {
                    console.error('Error during authentication:', error);
                });
            }

        }(window));
    </script>
    <script type="text/javascript" src="js/gse/gse-export.js" async onload="onEngineLoad()"></script>
</body>
</html>
