<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Telegram Mini App</title>
    <link rel="stylesheet" type="text/css" href="css/gse-style.css" />
    <link rel="stylesheet" type="text/css" href="css/gse-style-loading.css" />
    <style type="text/css">
        body {
            background-color: black;
            margin: 0;
            padding: 0;
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div id="gse-player" class="gse-frame">
        <div class="gse-overlay">
            <div id="gse-text" class="gse-dialog">
                <div>
                    <button id="gse-text-cancel">Cancel</button>
                    <button id="gse-text-done">Done</button>
                    <p id="gse-text-prompt"></p>
                </div>
                <div>
                    <textarea id="gse-text-input"></textarea>
                </div>
            </div>
            <div id="gse-browser" class="gse-dialog">            
                <iframe id="gse-browser-frame"></iframe>
                <button id="gse-browser-close" href="#">&#10006;</button>
            </div>
            <div id="gse-loading" style="visibility: visible;">
                <img src="images/gse-loading.png" />
            </div>
        </div>
    </div>
    <script type="text/javascript">
        (function(global) {
            global.onEngineLoad = function() {
                gse.ready(function(engine) {
                    var loadingElement = document.getElementById('gse-loading');
                    var playerDelegate = {
                        onLoadingBegin: function() {
                            engine.showOverlay();
                            loadingElement.style.visibility = 'visible';
                        },
                        onLoadingEnd: function() {
                            loadingElement.style.visibility = 'hidden';
                            engine.hideOverlay();
                        },
                        onWindowResize: function() {
                            engine.relayout();
                        }
                    };
                    engine.appendDelegate(playerDelegate);
                    window.addEventListener('resize', playerDelegate.onWindowResize, false);
                    var MUTE_ON_HIDDEN = false;
                    if (MUTE_ON_HIDDEN) {
                        document.addEventListener("visibilitychange", onVisibilityChanged, false);
                        document.addEventListener("mozvisibilitychange", onVisibilityChanged, false);
                        document.addEventListener("webkitvisibilitychange", onVisibilityChanged, false);
                        document.addEventListener("msvisibilitychange", onVisibilityChanged, false);
                        function onVisibilityChanged() {
                            if (document.hidden || document.mozHidden || document.webkitHidden || document.msHidden)
                                gse.setGameVolume(engine, 0);
                            else
                                gse.setGameVolume(engine, 1);
                        };
                    }
                    engine.setRenderFrame('gse-player');
                    engine.setOptions({
                        'viewport-reference': 'window',
                        'viewport-fit': 'letterbox'
                    });
                    engine.loadOptionsFromURL();
                    engine.play();
                });
            };
        }(window));

        // Fractal Integration
        const CLIENT_ID = 'AL1szGybA0YVtyC5Jk5w3z6hBPCPvy6P';
        const CLIENT_SECRET = 'PxkK_3u7n9Zn89wYxGjUEo-iZBxulnTVmepU-DfYAisraw_LkCC9fj1cS4scPUm4';
        const FRACTAL_API_BASE_URL = 'https://auth-api.fractal.is';
        let codeVerifier, codeChallenge;

        function generateCodeVerifier() {
            const array = new Uint32Array(56 / 2);
            window.crypto.getRandomValues(array);
            return Array.from(array, dec => ('0' + dec.toString(16)).substr(-2)).join('');
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
                .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        async function getApprovalUrl() {
            codeVerifier = generateCodeVerifier();
            codeChallenge = await generateCodeChallenge(codeVerifier);

            const authUrl = `${FRACTAL_API_BASE_URL}/auth/signin_v2/authorize`;
            const response = await fetch(authUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    clientId: CLIENT_ID,
                    scopes: ['identify', 'coins:read', 'items:read'],
                    codeChallenge: codeChallenge
                })
            });

            const data = await response.json();
            return data.approvalUrl;
        }

        async function verifyAuthentication() {
            const tokenUrl = `${FRACTAL_API_BASE_URL}/auth/signin_v2/token`;
            const response = await fetch(tokenUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    verifier: codeVerifier
                })
            });

            const data = await response.json();
            return data;
        }

        async function authenticateUser() {
            const approvalUrl = await getApprovalUrl();
            window.open(approvalUrl, '_blank');
            // Polling logic can be added here
        }

        async function postScore(accessToken, userId, score) {
            const postScoreUrl = `${FRACTAL_API_BASE_URL}/scores`;
            const response = await fetch(postScoreUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${accessToken}`
                },
                body: JSON.stringify({
                    userId: userId,
                    score: score
                })
            });

            const data = await response.json();
            return data;
        }

        async function fetchLeaderboard(accessToken) {
            const leaderboardUrl = `${FRACTAL_API_BASE_URL}/leaderboard`;
            const response = await fetch(leaderboardUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            });

            const data = await response.json();
            return data;
        }

        // GameSalad Delegates
        const gameSaladDelegate = {
            onGameCenterLogin: function() {
                return new Promise(async (resolve, reject) => {
                    try {
                        await authenticateUser();
                        // Implement polling to check for user authentication and get tokens
                        // For example, poll every 5 seconds
                        let authData;
                        const pollInterval = setInterval(async () => {
                            authData = await verifyAuthentication();
                            if (authData.bearerToken) {
                                clearInterval(pollInterval);
                                console.log('Authenticated User:', authData);
                                resolve();  // Resolve the promise to indicate login success
                            }
                        }, 5000); // Poll every 5 seconds
                    } catch (error) {
                        console.error('Error:', error);
                        reject(error);  // Reject the promise to indicate login failure
                    }
                });
            },
            onGameCenterPostScore: function(score, leaderboard) {
                return new Promise(async (resolve, reject) => {
                    try {
                        const authData = await verifyAuthentication();
                        const scorePostResponse = await postScore(authData.bearerToken, authData.userId, score);
                        console.log('Score Post Response:', scorePostResponse);
                        resolve();
                    } catch (error) {
                        console.error('Error:', error);
                        reject(error);
                    }
                });
            }
        };

        gse.ready(function(engine) {
            engine.appendDelegate(gameSaladDelegate);
        });

        document.getElementById('gse-text-done').addEventListener('click', async () => {
            try {
                await gameSaladDelegate.onGameCenterLogin();
                console.log('User logged in successfully.');
            } catch (error) {
                console.error('User login failed:', error);
            }
        });
    </script>
    <script type="text/javascript" src="js/gse/gse-export.js" async onload="onEngineLoad()"></script>
</body>
</html>
